---
title: Core concepts
description: "Xania's core concepts."
i18nReady: true
---
import { Counter } from "~/components/xania/Counter";
import { HelloWorld } from "~/components/xania/HelloWorld";
import { DoubleCounter } from "~/components/xania/DoubleCounter";
import { PokemonProfile } from  "~/components/xania/PokemonProfile";
import { PokemonApp } from "~/components/xania/PokemonApp";

**Function Components** are the building blocks of a xania application. They not only represents  the structure of the DOM, but also contains **commands** and **subscriptions**. In the following examples we will gradually learn about each these concepts.

### Hello world
Let's first start with a static / stateless example

```jsx
function HelloWorld(props: { name }) {
  const { name } = props;
  return (
    <button click={() => log(`hello ${name}!`)}>
      Say hello
    </button>
  );
}
```
<HelloWorld name="Ibrahim" client:only="xania"  />

JSX in **xania** looks much like **react**, props defines attributes and children (not used in this example) and `click` event is bound to a callback function which prints a log message to the console.

Next example will shows an example of dynamic Component, that is, view that depends on state that change over time.

### Counter Example

```jsx
function Counter() {
  // 1 state
  const count = state(1);
  // 2 update
  const increment = count.update((x) => x + 1)
  // 3 view
  return (
    <button click={increment}>
      Count: { count }
    </button>
  );
}
```
<Counter client:only="xania"  />

`Counter` component already has a couple of interesting elements. 

#### 1 state(...)

```jsx
  const count = state(1);
```

First we create a state with initial value of `1`. Naming is hard, `count` is not exactly a state object in the traditional sense, we cannot just peek into it to see the latest value after incrementing the count a couple of times. The actual value is stored and maintained in the xania runtime. the only way to access it's value is using update commands / messages

#### 2 update(...)
```jsx
  const increment = update(count, (x) => x + 1)
```
`button` Element binds the *click* event to the `increment` update command. Technically, `increment` is just a plain data object that describes how `count` change over time, it is also a special type of object which **Xania** accepts, instead of a callback function like we saw before in *Hello World* example.

When triggered, **Xania** runtime will execute the `increment` to update the runtime state of the `count` and update the text content of the button accordingly. 

### Derived / Computed state

In the following example we map every count value to it's double and present that in the view.

```jsx { 3 }
function Component() {
  const count = state(1)
  const double = count.map(x => x * 2);
  return (
    <button click={update(count, x => x + 1)}>
      Double: { double }
    </button>
  )
}
```
<DoubleCounter client:only="xania"  />

### Async Components

Let's say we have an api to *fetch* remote data.

```typescript
type Pokemon = { name: string }
function fetchPokemon (id) { 
  return fetch(`https://pokeapi.co/api/v2/pokemon/${id}`)
    .then(r => r.json())  as Promise<Pokemon>;
}

```

In **Xania**, using async / await is not limited to only *server components*. 
So we call `fetchPokemon` from inside our Component. We can do this because a *Function Component* is just a regular function that returns a view. In fact, calling `Pokemon({ id : 1})` is equivalent to `<Pokemon id={1}>`


```jsx { 2 }
async function Pokemon(props: { id }) {
  const pokemon = await fetchPokemon(id)
  return (
    <>
      <div>
        <b>{pokemon.name}</b>
      </div>
      <div>
        {abilities.map((a) => (
          <li>{a.name}</li>
        ))}
      </div>
    </>
  );
}

```
<PokemonProfile id="ditto" client:only="xania"  />

### Putting it all together

```jsx {5,11}
async function Component() {
  const pokemons = await fetchPokemons();

  const id = state(1);
  const pokemon = id.map(fetchPokemon);

  return (
    <h1>name: { pokemon.prop('name') }</h1>
    <h2>weight: { pokemon.prop('weight') }</h2>
    <button click={ id.update(
        x => 1 + x % pokemons.length )}>
      load next
    </button>
  )
}

function fetchPokemons() { 
  return fetch('https://pokeapi.co/api/v2/pokemon/')
    .then(e => e.json())
    .then(data => data.results);
}

```

<PokemonApp client:only="xania"  />

In this example we assembled everything we have learned so far to load pokemon data based on a selected id. We also introduced a new state operartor `prop` which is a short hand for the `map` operator.

