---
title: Basic concepts
description: "Xania's basic concepts."
i18nReady: true
---

**Function Components** are the building blocks of a xania application, they not only represents the structure of the DOM, but also contains (in terms of Elm) **commands** and **subscriptions**.

### Hello world
Let's first start with a static / stateless example

```jsx
function HelloWorld(props: { name, children }) {
  const { name } = props;
  return (
    <button click={() => log(`hello ${name}!`)}>
      Say hello
    </button>
  );
}
```

JSX in **xania** looks much like **react**, props defines attributes and children (not used in this example) and `click` event is bound to a callback function which prints a log message to the console.

Next example will shows an example of dynamic Component, that is, view that depends on state that change over time.

### Counter Example

```jsx
function Counter() {
  // 1 state
  const count = state(1);
  // 2 update
  const increment = update(count, (x) => x + 1)
  // 3 view
  return (
    <button click={increment}>
      Count: { count }
    </button>
  );
}
```

`Counter` component already has a couple of interesting elements. 

#### 1 state(...)

```jsx
  const count = state(1);
```

First we create a state with initial value of `1`. Naming is hard, `count` is not exactly a state object in the traditional sense, we cannot just peek into it to see the latest value after incrementing the count a couple of times. The actual value is stored and maintained in the xania runtime. the only way to access it's value is using update commands / messages

#### 2 update(...)
```jsx
  const increment = update(count, (x) => x + 1)
```
`button` Element binds the *click* event to the `increment` update command. Technically, `increment` is just a plain data object that describes how `count` change over time, it is also a special type of object which **Xania** accepts, instead of a callback function like we saw before in *Hello World* example.

When triggered, **Xania** runtime will execute the `increment` to update the runtime state of the `count` and update the text content of the button accordingly. 

### Derived / Computed state

In the following example we map every count value to it's double and present that in the view.

```jsx { 3 }
function Component() {
  const count = state(1)
  const double = count.map(x => x * 2);
  return (
    <button click={update(count, x => x + 1)}>
      Double: { double }
    </button>
  )
}
```

### Async Components

Let's say we have an api to *fetch* remote data.

```typescript
type Pokemon = { name: string }
function fetchPokemon (id) { 
  return fetch(`https://pokeapi.co/api/v2/pokemon/${id}`)
    .then(r => r.json())  as Promise<Pokemon>;
}

```

In **Xania**, using async / await is not limited to only *server components*. 
So we call `fetchPokemon` from inside our Component. We can do this because a *Function Component* is just a regular function that returns a view. In fact, calling `Pokemon({ id : 1})` is equivalent to `<Pokemon id={1}>`


```jsx { 2 }
async function Pokemon(props: { id }) {
  const pokemon = await fetchPokemon(id)
  return (
    <h1>{ pokemon.name }</h1>
  );
}

```

### Putting it all together

```jsx {5,11}
async function Component() {
  const pokemons = await fetchPokemons();

  const id = state(1);
  const pokemon = id.map(fetchPokemon);

  return (
    <h1>name: { pokemon.prop('name') }</h1>
    <h2>weight: { pokemon.prop('weight') }</h2>
    <button click={ id.update(
        x => 1 + x % pokemons.length )}>
      load next
    </button>
  )
}

function fetchPokemons() { 
  return fetch('https://pokeapi.co/api/v2/pokemon/')
    .then(e => e.json())
    .then(data => data.results);
}


```

In this example we assembled everything we have learned so far to load pokemon data based on a selected id. We also introduced a new state operartor `prop` which is a short hand for the `map` operator.

